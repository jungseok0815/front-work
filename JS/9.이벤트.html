<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        .area{
            border: 1px solid black;
            background: lightblue;
            height: 250px;
        }
    </style>
</head>
<body>
    <h1>이벤트(Event)</h1>
    <h2>1. 이벤트 모델 종류</h2>

    <h3>고전 이벤트 모델(기본 이벤트 모델)</h3>
    <p>
        특정 요소객체를 가지고와서 행당 용소의 이벤트 속성에 접근한 후<br>
        이벤트 핸들링을 연결하는 방식(이벤트를 제거할 수도 있음)
        
    </p>
    <button id="btn1">실행확인</button>
    <button id="btn2">실행학인</button>
    <div class="area" id="area1"></div>

    <script>
        const area1 = document.getElementById('area1');

        // const btn1= document.getElementById('btn1')
        // btn1.onclick=()=>{ //이벤트 핸들링
            
        // }
        document.getElementById('btn1').onclick = () =>{
            area1.innerHTML += 'btn1이 클릭되었습니다.<nr>'
        }

        document.getElementById('btn2').onclick = () =>{
            area1.innerHTML += 'btn2가 클릭되었습니다. btn1이벤트를 제거합니다.<nr>'
                document.getElementById('btn1').onclick = null;
        }


    </script>
    <br>

    <h3>인라인 이벤트 모델</h3>
    <p>
        요소 내부에 직접적으로 이벤트속성 제시해서 실행할 내용을 정의하는 방식<br>
        주로 script태그 내에 정의되어있는 함수 호출하는 방식을 선호
    </p>

    <button onclick="document.getElementById('area2').innerHTML += '첫번째 버특클릭'">실행확인</button>
    <button onclick="test1()">실행확인</button>
    <div class="area" id="area2"></div>

    <script>
        test1 = () =>{
            document.getElementById('area2').innerHTML += '두번째 버튼 클릭<br>';
        }
    </script>

    <h3>표준 이벤트 모델</h3>
    <p>
        w3c에서 공식적으로 지정한 이벤트 모델
        ie에서 9부터 사용하기 시작
    </p>

    <button id="btn3">실행확인</button>
    <script>
        const btn3 = document.getElementById('btn3');

        //이벤트 걸고자하는 요소객체.addEvebtListener('이벤트명',이벤트핸들러)
        btn3.addEventListener('click', () =>{
            alert('표준모델 테스트')
        })
        btn3.addEventListener('mouseenter', () =>{
            btn3.style.background = 'red';
        })
        btn3.addEventListener('mouseout', () =>{
            btn3.style.background = 'yellow';
        })
    </script>

    <hr>
    <h1>2. 현재 이벤트가 발생한 해당 요소 객체에 접근하는 방법</h1>
    
    <button id="btn4">고전이벤트 방식</button>
    <button id="btn5">표준이벤트 방식</button>
    <button onclick="test2(event)">인라인이벤트방식</button>

    <script>
        //고전이벤트 방식
        document.getElementById('btn4').onclick = (e) =>{ //이벤트핸들러
            console.log(e.target);      
            console.log(window.event.target);

            e.target.innerHTML = '버튼를림됨';
        }
        //표준이벤트방식

        document.getElementById('btn5').addEventListener('click',(e)=>{
            console.log(e)
            console.log(e.target)
        });

        test2 = (e) =>{
            e.target.style.background = 'red';
        }



    </script>

    <h1>3. 태그별 기본적으로 가지고있는 이벤트 제거</h1>

    <p>
        기본적으로 이벤트를 가지고 있는 요소<br>
        -a태그 : 클릭시 href에 제시되어있는 url요청하는 기본이벤트 보유<br>
        -form내의 submit버튼 클릭시 사용자가 입력한 값들을 action에 제시되어잇는 url로 제출
        <br><br>

        태그내에 기본적으로 설정되어있는 이벤트가 실행되지 않게금 막고싶다. <br>
        =>이벤트 핸들러의 return값을 false로 하면 기본이벤트 실행안됨
    </p>

    <a href="http://www.naver.com" onclick=" alert('이동?'); return false" >네이버로 이동</a>
    <a href="http://www.naver.com" onclick="return test4()" >네이버로 이동</a>

    <script>
        test4 = () =>{
            alert('이동합니까?');
            return false;
        }
    </script>

    <hr>
    <h3>로그인폼</h3>

    <form action="test.do" method="get">
        아이디: <input type="text" name="userId" id="userId"><br>
        비밀번호: <input type="password" name="userPwd" id="userPwd"><br>
        비밀번호 확인: <input type="password" id="checkPwd"><br>

        <input type="submit" onclick="return validate();">

    </form>

    <script>
        validate = () =>{
            
            const userPwd = document.getElementById('userPwd');
            const checkPwd = document.getElementById('checkPwd');

            const userid = document.getElementById('userId').vlaue;
            //아이디에 대한 유효성 검사
            //영문자 도는 숫자로만 5이상~12이하가 맞는지
            //맞지않을경우
            //알림창 출략 => 제출불가
            
            // if(userid.length >= 5 && userid.length <=12){// 글자수 제한
            //     //각자의 문자들이 영문 또는 숫자로만 이루어져있는지
            //     for(let i=0; i<userid.length; i++){
            //         let a = userid.charAt(i);
            //         console.log(a);
            //         if(a>=0 && a<10 || a>='a' && a<='z' || a>='A' && a<='Z' ){ //0~9로 이루어져있냐? , a~z로 이루어져있냐?

            //         }else{
            //             alert("아이디는 영문 또는 숫자로만 구성할 수 있습니다.");
            //             return false;
            //         }
            //     }

            // }else{
            //     alert("글자수가 ~~ ");
            //     return false;
            // }

            const regRxp = /^[a-zA-Z0-9]{5,12}$/;
            if(!regRxp.test(userid)){
                alert('유효한 아이디가 압니다.');
                return false;
            }
            
            //두개의 비밀번호가 일치하지 않을 경우
            //알림창 출력 => 제출불가하게 기본이벤트 막기

            if(userPwd.vlaue != checkPwd.vlaue){
                alert("비밀번호가 일치하지 않습니다.");
                return false;
            }
        }
    </script>
</body>
</html>